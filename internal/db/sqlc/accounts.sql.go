// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: accounts.sql

package sqlc

import (
	"context"
	"time"

	arian "ariand/internal/gen/arian/v1"
	"ariand/internal/types"
	"github.com/google/uuid"
)

const checkUserAccountAccess = `-- name: CheckUserAccountAccess :one
SELECT EXISTS(
  SELECT 1 FROM accounts a
  LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
  WHERE a.id = $2::bigint 
    AND (a.owner_id = $1::uuid OR au.user_id IS NOT NULL)
) AS has_access
`

type CheckUserAccountAccessParams struct {
	UserID    uuid.UUID `json:"user_id"`
	AccountID int64     `json:"account_id"`
}

func (q *Queries) CheckUserAccountAccess(ctx context.Context, arg CheckUserAccountAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserAccountAccess, arg.UserID, arg.AccountID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (
  owner_id, name, bank, account_type, alias,
  anchor_balance
) VALUES (
  $1::uuid,
  $2::text,
  $3::text,
  $4::smallint,
  $5::text,
  $6::jsonb
)
RETURNING id, owner_id, name, bank, account_type, alias,
          anchor_date, anchor_balance,
          created_at, updated_at
`

type CreateAccountParams struct {
	OwnerID       uuid.UUID `json:"owner_id"`
	Name          string    `json:"name"`
	Bank          string    `json:"bank"`
	AccountType   int16     `json:"account_type"`
	Alias         *string   `json:"alias"`
	AnchorBalance []byte    `json:"anchor_balance"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.OwnerID,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorBalance,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :execrows
DELETE FROM accounts 
WHERE id = $1::bigint AND owner_id = $2::uuid
`

type DeleteAccountParams struct {
	ID     int64     `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteAccount(ctx context.Context, arg DeleteAccountParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAccount, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAccount = `-- name: GetAccount :one
SELECT a.id, a.owner_id, a.name, a.bank, a.account_type, a.alias,
       a.anchor_date, a.anchor_balance,
       a.created_at, a.updated_at,
       (a.owner_id = $1::uuid) AS is_owner
FROM accounts a
LEFT JOIN account_users au ON au.account_id = a.id AND au.user_id = $1::uuid
WHERE a.id = $2::bigint
  AND (a.owner_id = $1::uuid OR au.user_id IS NOT NULL)
`

type GetAccountParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     int64     `json:"id"`
}

type GetAccountRow struct {
	ID            int64             `json:"id"`
	OwnerID       uuid.UUID         `json:"owner_id"`
	Name          string            `json:"name"`
	Bank          string            `json:"bank"`
	AccountType   arian.AccountType `json:"account_type"`
	Alias         *string           `json:"alias"`
	AnchorDate    time.Time         `json:"anchor_date"`
	AnchorBalance *types.Money      `json:"anchor_balance"`
	CreatedAt     time.Time         `json:"created_at"`
	UpdatedAt     time.Time         `json:"updated_at"`
	IsOwner       bool              `json:"is_owner"`
}

func (q *Queries) GetAccount(ctx context.Context, arg GetAccountParams) (GetAccountRow, error) {
	row := q.db.QueryRow(ctx, getAccount, arg.UserID, arg.ID)
	var i GetAccountRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsOwner,
	)
	return i, err
}

const getAccountAnchorBalance = `-- name: GetAccountAnchorBalance :one
SELECT anchor_balance
FROM accounts
WHERE id = $1::bigint
`

func (q *Queries) GetAccountAnchorBalance(ctx context.Context, id int64) (*types.Money, error) {
	row := q.db.QueryRow(ctx, getAccountAnchorBalance, id)
	var anchor_balance *types.Money
	err := row.Scan(&anchor_balance)
	return anchor_balance, err
}

const getAccountBalance = `-- name: GetAccountBalance :one
SELECT balance_after
FROM transactions
WHERE account_id = $1::bigint
ORDER BY tx_date DESC, id DESC
LIMIT 1
`

func (q *Queries) GetAccountBalance(ctx context.Context, accountID int64) (*types.Money, error) {
	row := q.db.QueryRow(ctx, getAccountBalance, accountID)
	var balance_after *types.Money
	err := row.Scan(&balance_after)
	return balance_after, err
}

const getUserAccountsCount = `-- name: GetUserAccountsCount :one
SELECT COUNT(*) AS account_count
FROM accounts a
LEFT JOIN account_users au ON a.id = au.account_id AND au.user_id = $1::uuid
WHERE a.owner_id = $1::uuid OR au.user_id IS NOT NULL
`

func (q *Queries) GetUserAccountsCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUserAccountsCount, userID)
	var account_count int64
	err := row.Scan(&account_count)
	return account_count, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT a.id, a.owner_id, a.name, a.bank, a.account_type, a.alias,
       a.anchor_date, a.anchor_balance,
       a.created_at, a.updated_at,
       (a.owner_id = $1::uuid) AS is_owner
FROM accounts a
LEFT JOIN account_users au ON au.account_id = a.id AND au.user_id = $1::uuid
WHERE a.owner_id = $1::uuid OR au.user_id IS NOT NULL
ORDER BY is_owner DESC, a.created_at
`

type ListAccountsRow struct {
	ID            int64             `json:"id"`
	OwnerID       uuid.UUID         `json:"owner_id"`
	Name          string            `json:"name"`
	Bank          string            `json:"bank"`
	AccountType   arian.AccountType `json:"account_type"`
	Alias         *string           `json:"alias"`
	AnchorDate    time.Time         `json:"anchor_date"`
	AnchorBalance *types.Money      `json:"anchor_balance"`
	CreatedAt     time.Time         `json:"created_at"`
	UpdatedAt     time.Time         `json:"updated_at"`
	IsOwner       bool              `json:"is_owner"`
}

func (q *Queries) ListAccounts(ctx context.Context, userID uuid.UUID) ([]ListAccountsRow, error) {
	rows, err := q.db.Query(ctx, listAccounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsRow
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Bank,
			&i.AccountType,
			&i.Alias,
			&i.AnchorDate,
			&i.AnchorBalance,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAccountAnchor = `-- name: SetAccountAnchor :execrows
UPDATE accounts
SET anchor_date = NOW()::date,
    anchor_balance = $1::jsonb
WHERE id = $2::bigint
`

type SetAccountAnchorParams struct {
	AnchorBalance []byte `json:"anchor_balance"`
	ID            int64  `json:"id"`
}

func (q *Queries) SetAccountAnchor(ctx context.Context, arg SetAccountAnchorParams) (int64, error) {
	result, err := q.db.Exec(ctx, setAccountAnchor, arg.AnchorBalance, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET name = COALESCE($1::text, name),
    bank = COALESCE($2::text, bank),
    account_type = COALESCE($3::smallint, account_type),
    alias = COALESCE($4::text, alias),
    anchor_date = COALESCE($5::date, anchor_date),
    anchor_balance = COALESCE($6::jsonb, anchor_balance)
WHERE id = $7::bigint
RETURNING id, owner_id, name, bank, account_type, alias,
          anchor_date, anchor_balance,
          created_at, updated_at
`

type UpdateAccountParams struct {
	Name          *string    `json:"name"`
	Bank          *string    `json:"bank"`
	AccountType   *int16     `json:"account_type"`
	Alias         *string    `json:"alias"`
	AnchorDate    *time.Time `json:"anchor_date"`
	AnchorBalance []byte     `json:"anchor_balance"`
	ID            int64      `json:"id"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorDate,
		arg.AnchorBalance,
		arg.ID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
