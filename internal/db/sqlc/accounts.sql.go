// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createAccount = `-- name: CreateAccount :one
insert into
  accounts (
    owner_id,
    name,
    bank,
    account_type,
    alias,
    anchor_balance_cents,
    anchor_currency,
    main_currency,
    colors
  )
values
  (
    $1::uuid,
    $2::text,
    $3::text,
    $4::smallint,
    $5::text,
    $6::bigint,
    $7::char(3),
    $8::char(3),
    $9::text []
  )
returning
  id, owner_id, name, bank, account_type, alias, anchor_date, anchor_balance_cents, anchor_currency, main_currency, colors, created_at, updated_at
`

type CreateAccountParams struct {
	OwnerID            uuid.UUID `db:"owner_id" json:"owner_id"`
	Name               string    `db:"name" json:"name"`
	Bank               string    `db:"bank" json:"bank"`
	AccountType        int16     `db:"account_type" json:"account_type"`
	Alias              *string   `db:"alias" json:"alias"`
	AnchorBalanceCents int64     `db:"anchor_balance_cents" json:"anchor_balance_cents"`
	AnchorCurrency     string    `db:"anchor_currency" json:"anchor_currency"`
	MainCurrency       string    `db:"main_currency" json:"main_currency"`
	Colors             []string  `db:"colors" json:"colors"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.OwnerID,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorBalanceCents,
		arg.AnchorCurrency,
		arg.MainCurrency,
		arg.Colors,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Bank,
		&i.AccountType,
		&i.Alias,
		&i.AnchorDate,
		&i.AnchorBalanceCents,
		&i.AnchorCurrency,
		&i.MainCurrency,
		&i.Colors,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :execrows
delete from
  accounts
where
  id = $1::bigint
  and owner_id = $2::uuid
`

type DeleteAccountParams struct {
	ID     int64     `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteAccount(ctx context.Context, arg DeleteAccountParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAccount, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAccount = `-- name: GetAccount :one
select
  a.id, a.owner_id, a.name, a.bank, a.account_type, a.alias, a.anchor_date, a.anchor_balance_cents, a.anchor_currency, a.main_currency, a.colors, a.created_at, a.updated_at,
  COALESCE(
    (select t.balance_after_cents
     from transactions t
     where t.account_id = a.id
     order by t.tx_date desc, t.id desc
     limit 1),
    a.anchor_balance_cents
  ) as balance_cents,
  COALESCE(
    (select t.balance_currency
     from transactions t
     where t.account_id = a.id
     order by t.tx_date desc, t.id desc
     limit 1),
    a.anchor_currency
  ) as balance_currency
from
  accounts a
  left join account_users au on au.account_id = a.id
  and au.user_id = $1::uuid
where
  a.id = $2::bigint
  and (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
`

type GetAccountParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	ID     int64     `db:"id" json:"id"`
}

type GetAccountRow struct {
	Account         Account `db:"account" json:"account"`
	BalanceCents    int64   `db:"balance_cents" json:"balance_cents"`
	BalanceCurrency string  `db:"balance_currency" json:"balance_currency"`
}

func (q *Queries) GetAccount(ctx context.Context, arg GetAccountParams) (GetAccountRow, error) {
	row := q.db.QueryRow(ctx, getAccount, arg.UserID, arg.ID)
	var i GetAccountRow
	err := row.Scan(
		&i.Account.ID,
		&i.Account.OwnerID,
		&i.Account.Name,
		&i.Account.Bank,
		&i.Account.AccountType,
		&i.Account.Alias,
		&i.Account.AnchorDate,
		&i.Account.AnchorBalanceCents,
		&i.Account.AnchorCurrency,
		&i.Account.MainCurrency,
		&i.Account.Colors,
		&i.Account.CreatedAt,
		&i.Account.UpdatedAt,
		&i.BalanceCents,
		&i.BalanceCurrency,
	)
	return i, err
}

const getAccountAnchorBalance = `-- name: GetAccountAnchorBalance :one
select
  anchor_balance_cents,
  anchor_currency
from
  accounts
where
  id = $1::bigint
`

type GetAccountAnchorBalanceRow struct {
	AnchorBalanceCents int64  `db:"anchor_balance_cents" json:"anchor_balance_cents"`
	AnchorCurrency     string `db:"anchor_currency" json:"anchor_currency"`
}

func (q *Queries) GetAccountAnchorBalance(ctx context.Context, id int64) (GetAccountAnchorBalanceRow, error) {
	row := q.db.QueryRow(ctx, getAccountAnchorBalance, id)
	var i GetAccountAnchorBalanceRow
	err := row.Scan(&i.AnchorBalanceCents, &i.AnchorCurrency)
	return i, err
}

const getAccountBalance = `-- name: GetAccountBalance :one
select
  balance_after_cents,
  balance_currency
from
  transactions
where
  account_id = $1::bigint
order by
  tx_date desc,
  id desc
limit
  1
`

type GetAccountBalanceRow struct {
	BalanceAfterCents *int64  `db:"balance_after_cents" json:"balance_after_cents"`
	BalanceCurrency   *string `db:"balance_currency" json:"balance_currency"`
}

func (q *Queries) GetAccountBalance(ctx context.Context, accountID int64) (GetAccountBalanceRow, error) {
	row := q.db.QueryRow(ctx, getAccountBalance, accountID)
	var i GetAccountBalanceRow
	err := row.Scan(&i.BalanceAfterCents, &i.BalanceCurrency)
	return i, err
}

const getUserAccountsCount = `-- name: GetUserAccountsCount :one
select
  COUNT(*) as account_count
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  a.owner_id = $1::uuid
  or au.user_id is not null
`

func (q *Queries) GetUserAccountsCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUserAccountsCount, userID)
	var account_count int64
	err := row.Scan(&account_count)
	return account_count, err
}

const listAccounts = `-- name: ListAccounts :many
select
  a.id, a.owner_id, a.name, a.bank, a.account_type, a.alias, a.anchor_date, a.anchor_balance_cents, a.anchor_currency, a.main_currency, a.colors, a.created_at, a.updated_at,
  COALESCE(
    (select t.balance_after_cents
     from transactions t
     where t.account_id = a.id
     order by t.tx_date desc, t.id desc
     limit 1),
    a.anchor_balance_cents
  ) as balance_cents,
  COALESCE(
    (select t.balance_currency
     from transactions t
     where t.account_id = a.id
     order by t.tx_date desc, t.id desc
     limit 1),
    a.anchor_currency
  ) as balance_currency
from
  accounts a
  left join account_users au on au.account_id = a.id
  and au.user_id = $1::uuid
where
  a.owner_id = $1::uuid
  or au.user_id is not null
order by
  (a.owner_id = $1::uuid) desc,
  a.created_at
`

type ListAccountsRow struct {
	Account         Account `db:"account" json:"account"`
	BalanceCents    int64   `db:"balance_cents" json:"balance_cents"`
	BalanceCurrency string  `db:"balance_currency" json:"balance_currency"`
}

func (q *Queries) ListAccounts(ctx context.Context, userID uuid.UUID) ([]ListAccountsRow, error) {
	rows, err := q.db.Query(ctx, listAccounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsRow
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(
			&i.Account.ID,
			&i.Account.OwnerID,
			&i.Account.Name,
			&i.Account.Bank,
			&i.Account.AccountType,
			&i.Account.Alias,
			&i.Account.AnchorDate,
			&i.Account.AnchorBalanceCents,
			&i.Account.AnchorCurrency,
			&i.Account.MainCurrency,
			&i.Account.Colors,
			&i.Account.CreatedAt,
			&i.Account.UpdatedAt,
			&i.BalanceCents,
			&i.BalanceCurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAccountAnchor = `-- name: SetAccountAnchor :execrows
update
  accounts
set
  anchor_date = now()::date,
  anchor_balance_cents = $1::bigint,
  anchor_currency = $2::char(3)
where
  id = $3::bigint
  and owner_id = $4::uuid
`

type SetAccountAnchorParams struct {
	AnchorBalanceCents int64     `db:"anchor_balance_cents" json:"anchor_balance_cents"`
	AnchorCurrency     string    `db:"anchor_currency" json:"anchor_currency"`
	ID                 int64     `db:"id" json:"id"`
	UserID             uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) SetAccountAnchor(ctx context.Context, arg SetAccountAnchorParams) (int64, error) {
	result, err := q.db.Exec(ctx, setAccountAnchor,
		arg.AnchorBalanceCents,
		arg.AnchorCurrency,
		arg.ID,
		arg.UserID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const syncAccountBalances = `-- name: SyncAccountBalances :exec
with anchor_transactions as (
  select
    t.id,
    t.account_id,
    t.tx_date,
    t.tx_direction,
    t.tx_amount_cents,
    a.main_currency,
    a.anchor_date,
    a.anchor_balance_cents,
    case when t.tx_date >= a.anchor_date then 1 else 0 end as is_after_anchor
  from
    transactions t
    join accounts a on t.account_id = a.id
  where
    t.account_id = $1::bigint
),
before_anchor as (
  select
    id,
    main_currency,
    anchor_balance_cents - COALESCE(sum(
      case
        when tx_direction = 1 then tx_amount_cents
        when tx_direction = 2 then -tx_amount_cents
        else 0
      end
    ) over (
      order by tx_date desc, id desc
      ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
    ), 0) as balance_after_cents
  from
    anchor_transactions
  where
    is_after_anchor = 0
),
after_anchor as (
  select
    id,
    main_currency,
    anchor_balance_cents + sum(
      case
        when tx_direction = 1 then tx_amount_cents
        when tx_direction = 2 then -tx_amount_cents
        else 0
      end
    ) over (
      order by tx_date, id
    ) as balance_after_cents
  from
    anchor_transactions
  where
    is_after_anchor = 1
)
update
  transactions
set
  balance_after_cents = coalesce(ba.balance_after_cents, aa.balance_after_cents),
  balance_currency = coalesce(ba.main_currency, aa.main_currency)
from
  before_anchor ba
  full outer join after_anchor aa on ba.id = aa.id
where
  transactions.id = coalesce(ba.id, aa.id)
`

func (q *Queries) SyncAccountBalances(ctx context.Context, accountID int64) error {
	_, err := q.db.Exec(ctx, syncAccountBalances, accountID)
	return err
}

const updateAccount = `-- name: UpdateAccount :exec
update
  accounts
set
  name = coalesce($1::text, name),
  bank = coalesce($2::text, bank),
  account_type = coalesce($3::smallint, account_type),
  alias = coalesce($4::text, alias),
  anchor_date = coalesce($5::date, anchor_date),
  anchor_balance_cents = coalesce($6::bigint, anchor_balance_cents),
  anchor_currency = coalesce($7::char(3), anchor_currency),
  main_currency = coalesce($8::char(3), main_currency),
  colors = coalesce($9::text [], colors)
where
  id = $10::bigint
  and owner_id = $11::uuid
`

type UpdateAccountParams struct {
	Name               *string    `db:"name" json:"name"`
	Bank               *string    `db:"bank" json:"bank"`
	AccountType        *int16     `db:"account_type" json:"account_type"`
	Alias              *string    `db:"alias" json:"alias"`
	AnchorDate         *time.Time `db:"anchor_date" json:"anchor_date"`
	AnchorBalanceCents *int64     `db:"anchor_balance_cents" json:"anchor_balance_cents"`
	AnchorCurrency     *string    `db:"anchor_currency" json:"anchor_currency"`
	MainCurrency       *string    `db:"main_currency" json:"main_currency"`
	Colors             []string   `db:"colors" json:"colors"`
	ID                 int64      `db:"id" json:"id"`
	UserID             uuid.UUID  `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) error {
	_, err := q.db.Exec(ctx, updateAccount,
		arg.Name,
		arg.Bank,
		arg.AccountType,
		arg.Alias,
		arg.AnchorDate,
		arg.AnchorBalanceCents,
		arg.AnchorCurrency,
		arg.MainCurrency,
		arg.Colors,
		arg.ID,
		arg.UserID,
	)
	return err
}
