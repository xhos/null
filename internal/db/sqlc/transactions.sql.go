// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package sqlc

import (
	"context"
	"time"

	arian "ariand/internal/gen/arian/v1"
	"ariand/internal/types"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkCategorizeTransactions = `-- name: BulkCategorizeTransactions :execrows
update
  transactions
set
  category_id = $1::bigint,
  category_manually_set = true -- manual categorization
where
  id = ANY($2::bigint [])
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $3::uuid
    where
      a.owner_id = $3::uuid
      or au.user_id is not null
  )
`

type BulkCategorizeTransactionsParams struct {
	CategoryID     int64     `db:"category_id" json:"category_id"`
	TransactionIds []int64   `db:"transaction_ids" json:"transaction_ids"`
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) BulkCategorizeTransactions(ctx context.Context, arg BulkCategorizeTransactionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkCategorizeTransactions, arg.CategoryID, arg.TransactionIds, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const bulkDeleteTransactions = `-- name: BulkDeleteTransactions :execrows
delete from
  transactions
where
  id = ANY($1::bigint [])
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $2::uuid
    where
      a.owner_id = $2::uuid
      or au.user_id is not null
  )
`

type BulkDeleteTransactionsParams struct {
	TransactionIds []int64   `db:"transaction_ids" json:"transaction_ids"`
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) BulkDeleteTransactions(ctx context.Context, arg BulkDeleteTransactionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkDeleteTransactions, arg.TransactionIds, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const categorizeTransactionAtomic = `-- name: CategorizeTransactionAtomic :one
update
  transactions
set
  category_id = $1::bigint,
  category_manually_set = $2::boolean,
  suggestions = $3::text []
where
  id = $4::bigint
  and category_manually_set = false -- Only update if not manually set
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $5::uuid
    where
      a.owner_id = $5::uuid
      or au.user_id is not null
  )
returning
  id,
  category_manually_set
`

type CategorizeTransactionAtomicParams struct {
	CategoryID          *int64    `db:"category_id" json:"category_id"`
	CategoryManuallySet bool      `db:"category_manually_set" json:"category_manually_set"`
	Suggestions         []string  `db:"suggestions" json:"suggestions"`
	ID                  int64     `db:"id" json:"id"`
	UserID              uuid.UUID `db:"user_id" json:"user_id"`
}

type CategorizeTransactionAtomicRow struct {
	ID                  int64 `db:"id" json:"id"`
	CategoryManuallySet bool  `db:"category_manually_set" json:"category_manually_set"`
}

func (q *Queries) CategorizeTransactionAtomic(ctx context.Context, arg CategorizeTransactionAtomicParams) (CategorizeTransactionAtomicRow, error) {
	row := q.db.QueryRow(ctx, categorizeTransactionAtomic,
		arg.CategoryID,
		arg.CategoryManuallySet,
		arg.Suggestions,
		arg.ID,
		arg.UserID,
	)
	var i CategorizeTransactionAtomicRow
	err := row.Scan(&i.ID, &i.CategoryManuallySet)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
insert into
  transactions (
    email_id,
    account_id,
    tx_date,
    tx_amount,
    tx_direction,
    tx_desc,
    balance_after,
    category_id,
    category_manually_set,
    merchant,
    merchant_manually_set,
    user_notes,
    foreign_amount,
    exchange_rate,
    suggestions,
    receipt_id
  )
select
  $1::text,
  $2::bigint,
  $3::timestamptz,
  $4::jsonb,
  $5::smallint,
  $6::text,
  $7::jsonb,
  $8::bigint,
  $9::boolean,
  $10::text,
  $11::boolean,
  $12::text,
  $13::jsonb,
  $14::double precision,
  $15::text [],
  $16::bigint
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $17::uuid
where
  a.id = $2::bigint
  and (
    a.owner_id = $17::uuid
    or au.user_id is not null
  )
returning
  id
`

type CreateTransactionParams struct {
	EmailID             *string   `db:"email_id" json:"email_id"`
	AccountID           int64     `db:"account_id" json:"account_id"`
	TxDate              time.Time `db:"tx_date" json:"tx_date"`
	TxAmount            []byte    `db:"tx_amount" json:"tx_amount"`
	TxDirection         int16     `db:"tx_direction" json:"tx_direction"`
	TxDesc              *string   `db:"tx_desc" json:"tx_desc"`
	BalanceAfter        []byte    `db:"balance_after" json:"balance_after"`
	CategoryID          *int64    `db:"category_id" json:"category_id"`
	CategoryManuallySet *bool     `db:"category_manually_set" json:"category_manually_set"`
	Merchant            *string   `db:"merchant" json:"merchant"`
	MerchantManuallySet *bool     `db:"merchant_manually_set" json:"merchant_manually_set"`
	UserNotes           *string   `db:"user_notes" json:"user_notes"`
	ForeignAmount       []byte    `db:"foreign_amount" json:"foreign_amount"`
	ExchangeRate        *float64  `db:"exchange_rate" json:"exchange_rate"`
	Suggestions         []string  `db:"suggestions" json:"suggestions"`
	ReceiptID           *int64    `db:"receipt_id" json:"receipt_id"`
	UserID              uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.EmailID,
		arg.AccountID,
		arg.TxDate,
		arg.TxAmount,
		arg.TxDirection,
		arg.TxDesc,
		arg.BalanceAfter,
		arg.CategoryID,
		arg.CategoryManuallySet,
		arg.Merchant,
		arg.MerchantManuallySet,
		arg.UserNotes,
		arg.ForeignAmount,
		arg.ExchangeRate,
		arg.Suggestions,
		arg.ReceiptID,
		arg.UserID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteTransaction = `-- name: DeleteTransaction :one
delete from
  transactions
where
  id = $1::bigint
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $2::uuid
    where
      a.owner_id = $2::uuid
      or au.user_id is not null
  )
returning
  account_id
`

type DeleteTransactionParams struct {
	ID     int64     `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteTransaction(ctx context.Context, arg DeleteTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteTransaction, arg.ID, arg.UserID)
	var account_id int64
	err := row.Scan(&account_id)
	return account_id, err
}

const findCandidateTransactions = `-- name: FindCandidateTransactions :many
select
  t.id, t.account_id, t.email_id, t.tx_date, t.tx_amount, t.tx_direction, t.tx_desc, t.balance_after, t.merchant, t.category_id, t.suggestions, t.user_notes, t.foreign_amount, t.exchange_rate, t.receipt_id, t.created_at, t.updated_at, t.category_manually_set, t.merchant_manually_set,
  similarity(t.tx_desc::text, $1::text) as merchant_score
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $2::uuid
where
  (
    a.owner_id = $2::uuid
    or au.user_id is not null
  )
  and t.receipt_id is null
  and t.tx_direction = 2
  and t.tx_date >= ($3::date - interval '60 days')
  and (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0 between $4::double precision and ($4::double precision * 1.20)
  and similarity(t.tx_desc::text, $1::text) > 0.3
order by
  merchant_score desc
limit
  10
`

type FindCandidateTransactionsParams struct {
	Merchant string    `db:"merchant" json:"merchant"`
	UserID   uuid.UUID `db:"user_id" json:"user_id"`
	Date     time.Time `db:"date" json:"date"`
	Total    float64   `db:"total" json:"total"`
}

type FindCandidateTransactionsRow struct {
	ID                  int64                      `db:"id" json:"id"`
	AccountID           int64                      `db:"account_id" json:"account_id"`
	EmailID             *string                    `db:"email_id" json:"email_id"`
	TxDate              time.Time                  `db:"tx_date" json:"tx_date"`
	TxAmount            *types.Money               `db:"tx_amount" json:"tx_amount"`
	TxDirection         arian.TransactionDirection `db:"tx_direction" json:"tx_direction"`
	TxDesc              *string                    `db:"tx_desc" json:"tx_desc"`
	BalanceAfter        *types.Money               `db:"balance_after" json:"balance_after"`
	Merchant            *string                    `db:"merchant" json:"merchant"`
	CategoryID          *int64                     `db:"category_id" json:"category_id"`
	Suggestions         []string                   `db:"suggestions" json:"suggestions"`
	UserNotes           *string                    `db:"user_notes" json:"user_notes"`
	ForeignAmount       *types.Money               `db:"foreign_amount" json:"foreign_amount"`
	ExchangeRate        *float64                   `db:"exchange_rate" json:"exchange_rate"`
	ReceiptID           *int64                     `db:"receipt_id" json:"receipt_id"`
	CreatedAt           time.Time                  `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time                  `db:"updated_at" json:"updated_at"`
	CategoryManuallySet bool                       `db:"category_manually_set" json:"category_manually_set"`
	MerchantManuallySet bool                       `db:"merchant_manually_set" json:"merchant_manually_set"`
	MerchantScore       float32                    `db:"merchant_score" json:"merchant_score"`
}

func (q *Queries) FindCandidateTransactions(ctx context.Context, arg FindCandidateTransactionsParams) ([]FindCandidateTransactionsRow, error) {
	rows, err := q.db.Query(ctx, findCandidateTransactions,
		arg.Merchant,
		arg.UserID,
		arg.Date,
		arg.Total,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCandidateTransactionsRow
	for rows.Next() {
		var i FindCandidateTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.EmailID,
			&i.TxDate,
			&i.TxAmount,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfter,
			&i.Merchant,
			&i.CategoryID,
			&i.Suggestions,
			&i.UserNotes,
			&i.ForeignAmount,
			&i.ExchangeRate,
			&i.ReceiptID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryManuallySet,
			&i.MerchantManuallySet,
			&i.MerchantScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountIDsFromTransactionIDs = `-- name: GetAccountIDsFromTransactionIDs :many
select
  distinct account_id
from
  transactions
where
  id = ANY($1::bigint [])
`

func (q *Queries) GetAccountIDsFromTransactionIDs(ctx context.Context, ids []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAccountIDsFromTransactionIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var account_id int64
		if err := rows.Scan(&account_id); err != nil {
			return nil, err
		}
		items = append(items, account_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
select
  t.id, t.account_id, t.email_id, t.tx_date, t.tx_amount, t.tx_direction, t.tx_desc, t.balance_after, t.merchant, t.category_id, t.suggestions, t.user_notes, t.foreign_amount, t.exchange_rate, t.receipt_id, t.created_at, t.updated_at, t.category_manually_set, t.merchant_manually_set
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  t.id = $2::bigint
  and (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
`

type GetTransactionParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	ID     int64     `db:"id" json:"id"`
}

func (q *Queries) GetTransaction(ctx context.Context, arg GetTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, arg.UserID, arg.ID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.EmailID,
		&i.TxDate,
		&i.TxAmount,
		&i.TxDirection,
		&i.TxDesc,
		&i.BalanceAfter,
		&i.Merchant,
		&i.CategoryID,
		&i.Suggestions,
		&i.UserNotes,
		&i.ForeignAmount,
		&i.ExchangeRate,
		&i.ReceiptID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryManuallySet,
		&i.MerchantManuallySet,
	)
	return i, err
}

const getTransactionCountByAccount = `-- name: GetTransactionCountByAccount :many
select
  a.id,
  a.name,
  COUNT(t.id) as transaction_count
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
  left join transactions t on a.id = t.account_id
where
  a.owner_id = $1::uuid
  or au.user_id is not null
group by
  a.id,
  a.name
order by
  transaction_count desc
`

type GetTransactionCountByAccountRow struct {
	ID               int64  `db:"id" json:"id"`
	Name             string `db:"name" json:"name"`
	TransactionCount int64  `db:"transaction_count" json:"transaction_count"`
}

func (q *Queries) GetTransactionCountByAccount(ctx context.Context, userID uuid.UUID) ([]GetTransactionCountByAccountRow, error) {
	rows, err := q.db.Query(ctx, getTransactionCountByAccount, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionCountByAccountRow
	for rows.Next() {
		var i GetTransactionCountByAccountRow
		if err := rows.Scan(&i.ID, &i.Name, &i.TransactionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllTransactions = `-- name: ListAllTransactions :many
select
  t.id, t.account_id, t.email_id, t.tx_date, t.tx_amount, t.tx_direction, t.tx_desc, t.balance_after, t.merchant, t.category_id, t.suggestions, t.user_notes, t.foreign_amount, t.exchange_rate, t.receipt_id, t.created_at, t.updated_at, t.category_manually_set, t.merchant_manually_set
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
order by
  t.tx_date desc,
  t.id desc
`

func (q *Queries) ListAllTransactions(ctx context.Context, userID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listAllTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.EmailID,
			&i.TxDate,
			&i.TxAmount,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfter,
			&i.Merchant,
			&i.CategoryID,
			&i.Suggestions,
			&i.UserNotes,
			&i.ForeignAmount,
			&i.ExchangeRate,
			&i.ReceiptID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryManuallySet,
			&i.MerchantManuallySet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
select
  t.id, t.account_id, t.email_id, t.tx_date, t.tx_amount, t.tx_direction, t.tx_desc, t.balance_after, t.merchant, t.category_id, t.suggestions, t.user_notes, t.foreign_amount, t.exchange_rate, t.receipt_id, t.created_at, t.updated_at, t.category_manually_set, t.merchant_manually_set
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
  left join categories c on t.category_id = c.id
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
  and (
    $2::timestamptz is null
    or $3::bigint is null
    or (t.tx_date, t.id) < (
      $2::timestamptz,
      $3::bigint
    )
  )
  and (
    $4::timestamptz is null
    or t.tx_date >= $4::timestamptz
  )
  and (
    $5::timestamptz is null
    or t.tx_date <= $5::timestamptz
  )
  and (
    $6::double precision is null
    or (t.tx_amount ->> 'units')::bigint >= $6::double precision
  )
  and (
    $7::double precision is null
    or (t.tx_amount ->> 'units')::bigint <= $7::double precision
  )
  and (
    $8::smallint is null
    or t.tx_direction = $8::smallint
  )
  and (
    $9::bigint [] is null
    or t.account_id = ANY($9::bigint [])
  )
  and (
    $10::text [] is null
    or c.slug = ANY($10::text [])
  )
  and (
    $11::text is null
    or t.merchant ILIKE ('%' || $11::text || '%')
  )
  and (
    $12::text is null
    or t.tx_desc ILIKE ('%' || $12::text || '%')
  )
  and (
    $13::char(3) is null
    or t.tx_amount ->> 'currency_code' = $13::char(3)
  )
  and (
    $14::time is null
    or t.tx_date::time >= $14::time
  )
  and (
    $15::time is null
    or t.tx_date::time <= $15::time
  )
  and (
    $16::boolean is null
    or (
      $16::boolean = true
      and t.category_id is null
    )
  )
order by
  t.tx_date desc,
  t.id desc
limit
  COALESCE($17::int, 100)
`

type ListTransactionsParams struct {
	UserID        uuid.UUID   `db:"user_id" json:"user_id"`
	CursorDate    *time.Time  `db:"cursor_date" json:"cursor_date"`
	CursorID      *int64      `db:"cursor_id" json:"cursor_id"`
	Start         *time.Time  `db:"start" json:"start"`
	End           *time.Time  `db:"end" json:"end"`
	AmountMin     *float64    `db:"amount_min" json:"amount_min"`
	AmountMax     *float64    `db:"amount_max" json:"amount_max"`
	Direction     *int16      `db:"direction" json:"direction"`
	AccountIds    []int64     `db:"account_ids" json:"account_ids"`
	Categories    []string    `db:"categories" json:"categories"`
	MerchantQ     *string     `db:"merchant_q" json:"merchant_q"`
	DescQ         *string     `db:"desc_q" json:"desc_q"`
	Currency      *string     `db:"currency" json:"currency"`
	TodStart      pgtype.Time `db:"tod_start" json:"tod_start"`
	TodEnd        pgtype.Time `db:"tod_end" json:"tod_end"`
	Uncategorized *bool       `db:"uncategorized" json:"uncategorized"`
	Limit         *int32      `db:"limit" json:"limit"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.UserID,
		arg.CursorDate,
		arg.CursorID,
		arg.Start,
		arg.End,
		arg.AmountMin,
		arg.AmountMax,
		arg.Direction,
		arg.AccountIds,
		arg.Categories,
		arg.MerchantQ,
		arg.DescQ,
		arg.Currency,
		arg.TodStart,
		arg.TodEnd,
		arg.Uncategorized,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.EmailID,
			&i.TxDate,
			&i.TxAmount,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfter,
			&i.Merchant,
			&i.CategoryID,
			&i.Suggestions,
			&i.UserNotes,
			&i.ForeignAmount,
			&i.ExchangeRate,
			&i.ReceiptID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryManuallySet,
			&i.MerchantManuallySet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recalculateBalancesAfterTransaction = `-- name: RecalculateBalancesAfterTransaction :exec
with transaction_deltas as (
  select
    id,
    SUM(
      case
        when tx_direction = 1 then (tx_amount ->> 'units')::bigint + (tx_amount ->> 'nanos')::bigint / 1000000000.0
        else -(
          (tx_amount ->> 'units')::bigint + (tx_amount ->> 'nanos')::bigint / 1000000000.0
        )
      end
    ) OVER (
      partition BY account_id
      order by
        tx_date,
        id
    ) as running_delta
  from
    transactions
  where
    account_id = $1::bigint
    and (
      tx_date > $2::timestamptz
      or (
        tx_date = $2::timestamptz
        and id >= $3::bigint
      )
    )
),
anchor_point as (
  select
    a.anchor_balance,
    COALESCE(
      SUM(
        case
          when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
          else -(
            (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
          )
        end
      ),
      0.0
    ) as delta_at_anchor
  from
    accounts a
    left join transactions t on t.account_id = a.id
    and t.tx_date < a.anchor_date
  where
    a.id = $1::bigint
  group by
    a.id,
    a.anchor_balance
)
update
  transactions
set
  balance_after = jsonb_build_object(
    'currency_code',
    tx_amount ->> 'currency_code',
    'units',
    (
      (ap.anchor_balance ->> 'units')::bigint + td.running_delta - ap.delta_at_anchor
    )::bigint,
    'nanos',
    0
  )
from
  transaction_deltas td,
  anchor_point ap
where
  transactions.id = td.id
  and transactions.account_id = $1::bigint
`

type RecalculateBalancesAfterTransactionParams struct {
	AccountID int64     `db:"account_id" json:"account_id"`
	FromDate  time.Time `db:"from_date" json:"from_date"`
	FromID    int64     `db:"from_id" json:"from_id"`
}

// Recalculate balance_after for all transactions after a given date/id
func (q *Queries) RecalculateBalancesAfterTransaction(ctx context.Context, arg RecalculateBalancesAfterTransactionParams) error {
	_, err := q.db.Exec(ctx, recalculateBalancesAfterTransaction, arg.AccountID, arg.FromDate, arg.FromID)
	return err
}

const setTransactionReceipt = `-- name: SetTransactionReceipt :execrows
update
  transactions
set
  receipt_id = $1::bigint
where
  id = $2::bigint
  and receipt_id is null
`

type SetTransactionReceiptParams struct {
	ReceiptID int64 `db:"receipt_id" json:"receipt_id"`
	ID        int64 `db:"id" json:"id"`
}

func (q *Queries) SetTransactionReceipt(ctx context.Context, arg SetTransactionReceiptParams) (int64, error) {
	result, err := q.db.Exec(ctx, setTransactionReceipt, arg.ReceiptID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const syncAccountBalances = `-- name: SyncAccountBalances :exec
with transaction_deltas as (
  select
    id,
    SUM(
      case
        when tx_direction = 1 then (tx_amount ->> 'units')::bigint + (tx_amount ->> 'nanos')::bigint / 1000000000.0
        else -(
          (tx_amount ->> 'units')::bigint + (tx_amount ->> 'nanos')::bigint / 1000000000.0
        )
      end
    ) OVER (
      partition BY account_id
      order by
        tx_date,
        id
    ) as running_delta
  from
    transactions
  where
    account_id = $1::bigint
),
anchor_point as (
  select
    a.anchor_balance,
    COALESCE(
      SUM(
        case
          when t.tx_direction = 1 then (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
          else -(
            (t.tx_amount ->> 'units')::bigint + (t.tx_amount ->> 'nanos')::bigint / 1000000000.0
          )
        end
      ),
      0.0
    ) as delta_at_anchor
  from
    accounts a
    left join transactions t on t.account_id = a.id
    and t.tx_date < a.anchor_date
  where
    a.id = $1::bigint
  group by
    a.id,
    a.anchor_balance
)
update
  transactions
set
  balance_after = jsonb_build_object(
    'currency_code',
    tx_amount ->> 'currency_code',
    'units',
    (
      (ap.anchor_balance ->> 'units')::bigint + td.running_delta - ap.delta_at_anchor
    )::bigint,
    'nanos',
    0
  )
from
  transaction_deltas td,
  anchor_point ap
where
  transactions.id = td.id
  and transactions.account_id = $1::bigint
`

func (q *Queries) SyncAccountBalances(ctx context.Context, accountID int64) error {
	_, err := q.db.Exec(ctx, syncAccountBalances, accountID)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :one
update
  transactions
set
  email_id = coalesce($1::text, email_id),
  tx_date = coalesce($2::timestamptz, tx_date),
  tx_amount = coalesce($3::jsonb, tx_amount),
  tx_direction = coalesce($4::smallint, tx_direction),
  tx_desc = coalesce($5::text, tx_desc),
  category_id = coalesce($6::bigint, category_id),
  merchant = coalesce($7::text, merchant),
  user_notes = coalesce($8::text, user_notes),
  foreign_amount = coalesce($9::jsonb, foreign_amount),
  exchange_rate = coalesce($10::double precision, exchange_rate),
  suggestions = coalesce($11::text[], suggestions),
  receipt_id = coalesce($12::bigint, receipt_id),
  category_manually_set = coalesce($13::boolean, category_manually_set),
  merchant_manually_set = coalesce($14::boolean, merchant_manually_set)
where
  id = $15::bigint
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $16::uuid
    where
      a.owner_id = $16::uuid
      or au.user_id is not null
  )
returning
  account_id
`

type UpdateTransactionParams struct {
	EmailID             *string    `db:"email_id" json:"email_id"`
	TxDate              *time.Time `db:"tx_date" json:"tx_date"`
	TxAmount            []byte     `db:"tx_amount" json:"tx_amount"`
	TxDirection         *int16     `db:"tx_direction" json:"tx_direction"`
	TxDesc              *string    `db:"tx_desc" json:"tx_desc"`
	CategoryID          *int64     `db:"category_id" json:"category_id"`
	Merchant            *string    `db:"merchant" json:"merchant"`
	UserNotes           *string    `db:"user_notes" json:"user_notes"`
	ForeignAmount       []byte     `db:"foreign_amount" json:"foreign_amount"`
	ExchangeRate        *float64   `db:"exchange_rate" json:"exchange_rate"`
	Suggestions         []string   `db:"suggestions" json:"suggestions"`
	ReceiptID           *int64     `db:"receipt_id" json:"receipt_id"`
	CategoryManuallySet *bool      `db:"category_manually_set" json:"category_manually_set"`
	MerchantManuallySet *bool      `db:"merchant_manually_set" json:"merchant_manually_set"`
	ID                  int64      `db:"id" json:"id"`
	UserID              uuid.UUID  `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateTransaction,
		arg.EmailID,
		arg.TxDate,
		arg.TxAmount,
		arg.TxDirection,
		arg.TxDesc,
		arg.CategoryID,
		arg.Merchant,
		arg.UserNotes,
		arg.ForeignAmount,
		arg.ExchangeRate,
		arg.Suggestions,
		arg.ReceiptID,
		arg.CategoryManuallySet,
		arg.MerchantManuallySet,
		arg.ID,
		arg.UserID,
	)
	var account_id int64
	err := row.Scan(&account_id)
	return account_id, err
}
