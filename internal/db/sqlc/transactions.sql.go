// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package sqlc

import (
	"context"
	"time"

	arian "ariand/internal/gen/arian/v1"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkCategorizeTransactions = `-- name: BulkCategorizeTransactions :execrows
update
  transactions
set
  category_id = $1::bigint,
  category_manually_set = true
where
  id = ANY($2::bigint [])
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $3::uuid
    where
      a.owner_id = $3::uuid
      or au.user_id is not null
  )
`

type BulkCategorizeTransactionsParams struct {
	CategoryID     int64     `db:"category_id" json:"category_id"`
	TransactionIds []int64   `db:"transaction_ids" json:"transaction_ids"`
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) BulkCategorizeTransactions(ctx context.Context, arg BulkCategorizeTransactionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkCategorizeTransactions, arg.CategoryID, arg.TransactionIds, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const bulkCreateTransactions = `-- name: BulkCreateTransactions :many
insert into
  transactions (
    account_id,
    tx_date,
    tx_amount_cents,
    tx_currency,
    tx_direction,
    tx_desc,
    category_id,
    merchant,
    user_notes,
    foreign_amount_cents,
    foreign_currency,
    exchange_rate
  )
select
  unnest($1::bigint[]),
  unnest($2::timestamptz[]),
  unnest($3::bigint[]),
  unnest($4::char(3)[]),
  unnest($5::smallint[]),
  unnest($6::text[]),
  unnest($7::bigint[]),
  unnest($8::text[]),
  unnest($9::text[]),
  unnest($10::bigint[]),
  unnest($11::char(3)[]),
  unnest($12::double precision[])
returning
  id, account_id, email_id, tx_date, tx_amount_cents, tx_currency, tx_direction, tx_desc, balance_after_cents, balance_currency, merchant, category_id, category_manually_set, merchant_manually_set, suggestions, user_notes, foreign_amount_cents, foreign_currency, exchange_rate, created_at, updated_at
`

type BulkCreateTransactionsParams struct {
	AccountIds         []int64     `db:"account_ids" json:"account_ids"`
	TxDates            []time.Time `db:"tx_dates" json:"tx_dates"`
	TxAmountCents      []int64     `db:"tx_amount_cents" json:"tx_amount_cents"`
	TxCurrencies       []string    `db:"tx_currencies" json:"tx_currencies"`
	TxDirections       []int16     `db:"tx_directions" json:"tx_directions"`
	TxDescs            []string    `db:"tx_descs" json:"tx_descs"`
	CategoryIds        []int64     `db:"category_ids" json:"category_ids"`
	Merchants          []string    `db:"merchants" json:"merchants"`
	UserNotes          []string    `db:"user_notes" json:"user_notes"`
	ForeignAmountCents []int64     `db:"foreign_amount_cents" json:"foreign_amount_cents"`
	ForeignCurrencies  []string    `db:"foreign_currencies" json:"foreign_currencies"`
	ExchangeRates      []float64   `db:"exchange_rates" json:"exchange_rates"`
}

func (q *Queries) BulkCreateTransactions(ctx context.Context, arg BulkCreateTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, bulkCreateTransactions,
		arg.AccountIds,
		arg.TxDates,
		arg.TxAmountCents,
		arg.TxCurrencies,
		arg.TxDirections,
		arg.TxDescs,
		arg.CategoryIds,
		arg.Merchants,
		arg.UserNotes,
		arg.ForeignAmountCents,
		arg.ForeignCurrencies,
		arg.ExchangeRates,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.EmailID,
			&i.TxDate,
			&i.TxAmountCents,
			&i.TxCurrency,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfterCents,
			&i.BalanceCurrency,
			&i.Merchant,
			&i.CategoryID,
			&i.CategoryManuallySet,
			&i.MerchantManuallySet,
			&i.Suggestions,
			&i.UserNotes,
			&i.ForeignAmountCents,
			&i.ForeignCurrency,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkDeleteTransactions = `-- name: BulkDeleteTransactions :execrows
delete from
  transactions
where
  id = ANY($1::bigint [])
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $2::uuid
    where
      a.owner_id = $2::uuid
      or au.user_id is not null
  )
`

type BulkDeleteTransactionsParams struct {
	TransactionIds []int64   `db:"transaction_ids" json:"transaction_ids"`
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) BulkDeleteTransactions(ctx context.Context, arg BulkDeleteTransactionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkDeleteTransactions, arg.TransactionIds, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const categorizeTransactionAtomic = `-- name: CategorizeTransactionAtomic :one
update
  transactions
set
  category_id = $1::bigint,
  category_manually_set = $2::boolean,
  suggestions = $3::text []
where
  id = $4::bigint
  and category_manually_set = false
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $5::uuid
    where
      a.owner_id = $5::uuid
      or au.user_id is not null
  )
returning
  id,
  category_manually_set
`

type CategorizeTransactionAtomicParams struct {
	CategoryID          *int64    `db:"category_id" json:"category_id"`
	CategoryManuallySet bool      `db:"category_manually_set" json:"category_manually_set"`
	Suggestions         []string  `db:"suggestions" json:"suggestions"`
	ID                  int64     `db:"id" json:"id"`
	UserID              uuid.UUID `db:"user_id" json:"user_id"`
}

type CategorizeTransactionAtomicRow struct {
	ID                  int64 `db:"id" json:"id"`
	CategoryManuallySet bool  `db:"category_manually_set" json:"category_manually_set"`
}

func (q *Queries) CategorizeTransactionAtomic(ctx context.Context, arg CategorizeTransactionAtomicParams) (CategorizeTransactionAtomicRow, error) {
	row := q.db.QueryRow(ctx, categorizeTransactionAtomic,
		arg.CategoryID,
		arg.CategoryManuallySet,
		arg.Suggestions,
		arg.ID,
		arg.UserID,
	)
	var i CategorizeTransactionAtomicRow
	err := row.Scan(&i.ID, &i.CategoryManuallySet)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
insert into
  transactions (
    email_id,
    account_id,
    tx_date,
    tx_amount_cents,
    tx_currency,
    tx_direction,
    tx_desc,
    balance_after_cents,
    balance_currency,
    category_id,
    category_manually_set,
    merchant,
    merchant_manually_set,
    user_notes,
    foreign_amount_cents,
    foreign_currency,
    exchange_rate,
    suggestions
  )
select
  $1::text,
  $2::bigint,
  $3::timestamptz,
  $4::bigint,
  $5::char(3),
  $6::smallint,
  $7::text,
  $8::bigint,
  $9::char(3),
  $10::bigint,
  $11::boolean,
  $12::text,
  $13::boolean,
  $14::text,
  $15::bigint,
  $16::char(3),
  $17::double precision,
  $18::text []
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $19::uuid
where
  a.id = $2::bigint
  and (
    a.owner_id = $19::uuid
    or au.user_id is not null
  )
returning
  id, account_id, email_id, tx_date, tx_amount_cents, tx_currency, tx_direction, tx_desc, balance_after_cents, balance_currency, merchant, category_id, category_manually_set, merchant_manually_set, suggestions, user_notes, foreign_amount_cents, foreign_currency, exchange_rate, created_at, updated_at
`

type CreateTransactionParams struct {
	EmailID             *string   `db:"email_id" json:"email_id"`
	AccountID           int64     `db:"account_id" json:"account_id"`
	TxDate              time.Time `db:"tx_date" json:"tx_date"`
	TxAmountCents       int64     `db:"tx_amount_cents" json:"tx_amount_cents"`
	TxCurrency          string    `db:"tx_currency" json:"tx_currency"`
	TxDirection         int16     `db:"tx_direction" json:"tx_direction"`
	TxDesc              *string   `db:"tx_desc" json:"tx_desc"`
	BalanceAfterCents   *int64    `db:"balance_after_cents" json:"balance_after_cents"`
	BalanceCurrency     *string   `db:"balance_currency" json:"balance_currency"`
	CategoryID          *int64    `db:"category_id" json:"category_id"`
	CategoryManuallySet *bool     `db:"category_manually_set" json:"category_manually_set"`
	Merchant            *string   `db:"merchant" json:"merchant"`
	MerchantManuallySet *bool     `db:"merchant_manually_set" json:"merchant_manually_set"`
	UserNotes           *string   `db:"user_notes" json:"user_notes"`
	ForeignAmountCents  *int64    `db:"foreign_amount_cents" json:"foreign_amount_cents"`
	ForeignCurrency     *string   `db:"foreign_currency" json:"foreign_currency"`
	ExchangeRate        *float64  `db:"exchange_rate" json:"exchange_rate"`
	Suggestions         []string  `db:"suggestions" json:"suggestions"`
	UserID              uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.EmailID,
		arg.AccountID,
		arg.TxDate,
		arg.TxAmountCents,
		arg.TxCurrency,
		arg.TxDirection,
		arg.TxDesc,
		arg.BalanceAfterCents,
		arg.BalanceCurrency,
		arg.CategoryID,
		arg.CategoryManuallySet,
		arg.Merchant,
		arg.MerchantManuallySet,
		arg.UserNotes,
		arg.ForeignAmountCents,
		arg.ForeignCurrency,
		arg.ExchangeRate,
		arg.Suggestions,
		arg.UserID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.EmailID,
		&i.TxDate,
		&i.TxAmountCents,
		&i.TxCurrency,
		&i.TxDirection,
		&i.TxDesc,
		&i.BalanceAfterCents,
		&i.BalanceCurrency,
		&i.Merchant,
		&i.CategoryID,
		&i.CategoryManuallySet,
		&i.MerchantManuallySet,
		&i.Suggestions,
		&i.UserNotes,
		&i.ForeignAmountCents,
		&i.ForeignCurrency,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTransaction = `-- name: DeleteTransaction :execrows
delete from
  transactions
where
  id = $1::bigint
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $2::uuid
    where
      a.owner_id = $2::uuid
      or au.user_id is not null
  )
`

type DeleteTransactionParams struct {
	ID     int64     `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteTransaction(ctx context.Context, arg DeleteTransactionParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTransaction, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findCandidateTransactions = `-- name: FindCandidateTransactions :many
select
  t.id, t.account_id, t.email_id, t.tx_date, t.tx_amount_cents, t.tx_currency, t.tx_direction, t.tx_desc, t.balance_after_cents, t.balance_currency, t.merchant, t.category_id, t.category_manually_set, t.merchant_manually_set, t.suggestions, t.user_notes, t.foreign_amount_cents, t.foreign_currency, t.exchange_rate, t.created_at, t.updated_at,
  similarity(t.tx_desc::text, $1::text) as merchant_score
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $2::uuid
where
  (
    a.owner_id = $2::uuid
    or au.user_id is not null
  )
  and t.tx_direction = 2
  and t.tx_date >= ($3::date - interval '60 days')
  and t.tx_amount_cents between $4::bigint and ($4::bigint * 120 / 100)
  and similarity(t.tx_desc::text, $1::text) > 0.3
order by
  merchant_score desc
limit
  10
`

type FindCandidateTransactionsParams struct {
	Merchant   string    `db:"merchant" json:"merchant"`
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	Date       time.Time `db:"date" json:"date"`
	TotalCents int64     `db:"total_cents" json:"total_cents"`
}

type FindCandidateTransactionsRow struct {
	ID                  int64                      `db:"id" json:"id"`
	AccountID           int64                      `db:"account_id" json:"account_id"`
	EmailID             *string                    `db:"email_id" json:"email_id"`
	TxDate              time.Time                  `db:"tx_date" json:"tx_date"`
	TxAmountCents       int64                      `db:"tx_amount_cents" json:"tx_amount_cents"`
	TxCurrency          string                     `db:"tx_currency" json:"tx_currency"`
	TxDirection         arian.TransactionDirection `db:"tx_direction" json:"tx_direction"`
	TxDesc              *string                    `db:"tx_desc" json:"tx_desc"`
	BalanceAfterCents   *int64                     `db:"balance_after_cents" json:"balance_after_cents"`
	BalanceCurrency     *string                    `db:"balance_currency" json:"balance_currency"`
	Merchant            *string                    `db:"merchant" json:"merchant"`
	CategoryID          *int64                     `db:"category_id" json:"category_id"`
	CategoryManuallySet bool                       `db:"category_manually_set" json:"category_manually_set"`
	MerchantManuallySet bool                       `db:"merchant_manually_set" json:"merchant_manually_set"`
	Suggestions         []string                   `db:"suggestions" json:"suggestions"`
	UserNotes           *string                    `db:"user_notes" json:"user_notes"`
	ForeignAmountCents  *int64                     `db:"foreign_amount_cents" json:"foreign_amount_cents"`
	ForeignCurrency     *string                    `db:"foreign_currency" json:"foreign_currency"`
	ExchangeRate        *float64                   `db:"exchange_rate" json:"exchange_rate"`
	CreatedAt           time.Time                  `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time                  `db:"updated_at" json:"updated_at"`
	MerchantScore       float32                    `db:"merchant_score" json:"merchant_score"`
}

func (q *Queries) FindCandidateTransactions(ctx context.Context, arg FindCandidateTransactionsParams) ([]FindCandidateTransactionsRow, error) {
	rows, err := q.db.Query(ctx, findCandidateTransactions,
		arg.Merchant,
		arg.UserID,
		arg.Date,
		arg.TotalCents,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCandidateTransactionsRow
	for rows.Next() {
		var i FindCandidateTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.EmailID,
			&i.TxDate,
			&i.TxAmountCents,
			&i.TxCurrency,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfterCents,
			&i.BalanceCurrency,
			&i.Merchant,
			&i.CategoryID,
			&i.CategoryManuallySet,
			&i.MerchantManuallySet,
			&i.Suggestions,
			&i.UserNotes,
			&i.ForeignAmountCents,
			&i.ForeignCurrency,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MerchantScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountIDsFromTransactionIDs = `-- name: GetAccountIDsFromTransactionIDs :many
select
  distinct account_id
from
  transactions
where
  id = ANY($1::bigint [])
`

func (q *Queries) GetAccountIDsFromTransactionIDs(ctx context.Context, ids []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAccountIDsFromTransactionIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var account_id int64
		if err := rows.Scan(&account_id); err != nil {
			return nil, err
		}
		items = append(items, account_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
select
  t.id, t.account_id, t.email_id, t.tx_date, t.tx_amount_cents, t.tx_currency, t.tx_direction, t.tx_desc, t.balance_after_cents, t.balance_currency, t.merchant, t.category_id, t.category_manually_set, t.merchant_manually_set, t.suggestions, t.user_notes, t.foreign_amount_cents, t.foreign_currency, t.exchange_rate, t.created_at, t.updated_at
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  t.id = $2::bigint
  and (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
`

type GetTransactionParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	ID     int64     `db:"id" json:"id"`
}

func (q *Queries) GetTransaction(ctx context.Context, arg GetTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, arg.UserID, arg.ID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.EmailID,
		&i.TxDate,
		&i.TxAmountCents,
		&i.TxCurrency,
		&i.TxDirection,
		&i.TxDesc,
		&i.BalanceAfterCents,
		&i.BalanceCurrency,
		&i.Merchant,
		&i.CategoryID,
		&i.CategoryManuallySet,
		&i.MerchantManuallySet,
		&i.Suggestions,
		&i.UserNotes,
		&i.ForeignAmountCents,
		&i.ForeignCurrency,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionCountByAccount = `-- name: GetTransactionCountByAccount :many
select
  a.id,
  a.name,
  COUNT(t.id) as transaction_count
from
  accounts a
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
  left join transactions t on a.id = t.account_id
where
  a.owner_id = $1::uuid
  or au.user_id is not null
group by
  a.id,
  a.name
order by
  transaction_count desc
`

type GetTransactionCountByAccountRow struct {
	ID               int64  `db:"id" json:"id"`
	Name             string `db:"name" json:"name"`
	TransactionCount int64  `db:"transaction_count" json:"transaction_count"`
}

func (q *Queries) GetTransactionCountByAccount(ctx context.Context, userID uuid.UUID) ([]GetTransactionCountByAccountRow, error) {
	rows, err := q.db.Query(ctx, getTransactionCountByAccount, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionCountByAccountRow
	for rows.Next() {
		var i GetTransactionCountByAccountRow
		if err := rows.Scan(&i.ID, &i.Name, &i.TransactionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllTransactions = `-- name: ListAllTransactions :many
select
  t.id, t.account_id, t.email_id, t.tx_date, t.tx_amount_cents, t.tx_currency, t.tx_direction, t.tx_desc, t.balance_after_cents, t.balance_currency, t.merchant, t.category_id, t.category_manually_set, t.merchant_manually_set, t.suggestions, t.user_notes, t.foreign_amount_cents, t.foreign_currency, t.exchange_rate, t.created_at, t.updated_at
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
order by
  t.tx_date desc,
  t.id desc
`

func (q *Queries) ListAllTransactions(ctx context.Context, userID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listAllTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.EmailID,
			&i.TxDate,
			&i.TxAmountCents,
			&i.TxCurrency,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfterCents,
			&i.BalanceCurrency,
			&i.Merchant,
			&i.CategoryID,
			&i.CategoryManuallySet,
			&i.MerchantManuallySet,
			&i.Suggestions,
			&i.UserNotes,
			&i.ForeignAmountCents,
			&i.ForeignCurrency,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
select
  t.id, t.account_id, t.email_id, t.tx_date, t.tx_amount_cents, t.tx_currency, t.tx_direction, t.tx_desc, t.balance_after_cents, t.balance_currency, t.merchant, t.category_id, t.category_manually_set, t.merchant_manually_set, t.suggestions, t.user_notes, t.foreign_amount_cents, t.foreign_currency, t.exchange_rate, t.created_at, t.updated_at
from
  transactions t
  join accounts a on t.account_id = a.id
  left join account_users au on a.id = au.account_id
  and au.user_id = $1::uuid
  left join categories c on t.category_id = c.id
where
  (
    a.owner_id = $1::uuid
    or au.user_id is not null
  )
  and (
    $2::timestamptz is null
    or $3::bigint is null
    or (t.tx_date, t.id) < (
      $2::timestamptz,
      $3::bigint
    )
  )
  and (
    $4::timestamptz is null
    or t.tx_date >= $4::timestamptz
  )
  and (
    $5::timestamptz is null
    or t.tx_date <= $5::timestamptz
  )
  and (
    $6::bigint is null
    or t.tx_amount_cents >= $6::bigint
  )
  and (
    $7::bigint is null
    or t.tx_amount_cents <= $7::bigint
  )
  and (
    $8::smallint is null
    or t.tx_direction = $8::smallint
  )
  and (
    $9::bigint [] is null
    or t.account_id = ANY($9::bigint [])
  )
  and (
    $10::text [] is null
    or c.slug = ANY($10::text [])
  )
  and (
    $11::text is null
    or t.merchant ILIKE ('%' || $11::text || '%')
  )
  and (
    $12::text is null
    or t.tx_desc ILIKE ('%' || $12::text || '%')
  )
  and (
    $13::char(3) is null
    or t.tx_currency = $13::char(3)
  )
  and (
    $14::time is null
    or t.tx_date::time >= $14::time
  )
  and (
    $15::time is null
    or t.tx_date::time <= $15::time
  )
  and (
    $16::boolean is null
    or (
      $16::boolean = true
      and t.category_id is null
    )
  )
order by
  t.tx_date desc,
  t.id desc
limit
  COALESCE($17::int, 100)
`

type ListTransactionsParams struct {
	UserID         uuid.UUID   `db:"user_id" json:"user_id"`
	CursorDate     *time.Time  `db:"cursor_date" json:"cursor_date"`
	CursorID       *int64      `db:"cursor_id" json:"cursor_id"`
	Start          *time.Time  `db:"start" json:"start"`
	End            *time.Time  `db:"end" json:"end"`
	AmountMinCents *int64      `db:"amount_min_cents" json:"amount_min_cents"`
	AmountMaxCents *int64      `db:"amount_max_cents" json:"amount_max_cents"`
	Direction      *int16      `db:"direction" json:"direction"`
	AccountIds     []int64     `db:"account_ids" json:"account_ids"`
	Categories     []string    `db:"categories" json:"categories"`
	MerchantQ      *string     `db:"merchant_q" json:"merchant_q"`
	DescQ          *string     `db:"desc_q" json:"desc_q"`
	Currency       *string     `db:"currency" json:"currency"`
	TodStart       pgtype.Time `db:"tod_start" json:"tod_start"`
	TodEnd         pgtype.Time `db:"tod_end" json:"tod_end"`
	Uncategorized  *bool       `db:"uncategorized" json:"uncategorized"`
	Limit          *int32      `db:"limit" json:"limit"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.UserID,
		arg.CursorDate,
		arg.CursorID,
		arg.Start,
		arg.End,
		arg.AmountMinCents,
		arg.AmountMaxCents,
		arg.Direction,
		arg.AccountIds,
		arg.Categories,
		arg.MerchantQ,
		arg.DescQ,
		arg.Currency,
		arg.TodStart,
		arg.TodEnd,
		arg.Uncategorized,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.EmailID,
			&i.TxDate,
			&i.TxAmountCents,
			&i.TxCurrency,
			&i.TxDirection,
			&i.TxDesc,
			&i.BalanceAfterCents,
			&i.BalanceCurrency,
			&i.Merchant,
			&i.CategoryID,
			&i.CategoryManuallySet,
			&i.MerchantManuallySet,
			&i.Suggestions,
			&i.UserNotes,
			&i.ForeignAmountCents,
			&i.ForeignCurrency,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransaction = `-- name: UpdateTransaction :exec
update
  transactions
set
  email_id = coalesce($1::text, email_id),
  tx_date = coalesce($2::timestamptz, tx_date),
  tx_amount_cents = coalesce($3::bigint, tx_amount_cents),
  tx_currency = coalesce($4::char(3), tx_currency),
  tx_direction = coalesce($5::smallint, tx_direction),
  tx_desc = coalesce($6::text, tx_desc),
  category_id = coalesce($7::bigint, category_id),
  merchant = coalesce($8::text, merchant),
  user_notes = coalesce($9::text, user_notes),
  foreign_amount_cents = coalesce($10::bigint, foreign_amount_cents),
  foreign_currency = coalesce($11::char(3), foreign_currency),
  exchange_rate = coalesce($12::double precision, exchange_rate),
  suggestions = coalesce($13::text[], suggestions),
  category_manually_set = coalesce($14::boolean, category_manually_set),
  merchant_manually_set = coalesce($15::boolean, merchant_manually_set)
where
  id = $16::bigint
  and account_id in (
    select
      a.id
    from
      accounts a
      left join account_users au on a.id = au.account_id
      and au.user_id = $17::uuid
    where
      a.owner_id = $17::uuid
      or au.user_id is not null
  )
`

type UpdateTransactionParams struct {
	EmailID             *string    `db:"email_id" json:"email_id"`
	TxDate              *time.Time `db:"tx_date" json:"tx_date"`
	TxAmountCents       *int64     `db:"tx_amount_cents" json:"tx_amount_cents"`
	TxCurrency          *string    `db:"tx_currency" json:"tx_currency"`
	TxDirection         *int16     `db:"tx_direction" json:"tx_direction"`
	TxDesc              *string    `db:"tx_desc" json:"tx_desc"`
	CategoryID          *int64     `db:"category_id" json:"category_id"`
	Merchant            *string    `db:"merchant" json:"merchant"`
	UserNotes           *string    `db:"user_notes" json:"user_notes"`
	ForeignAmountCents  *int64     `db:"foreign_amount_cents" json:"foreign_amount_cents"`
	ForeignCurrency     *string    `db:"foreign_currency" json:"foreign_currency"`
	ExchangeRate        *float64   `db:"exchange_rate" json:"exchange_rate"`
	Suggestions         []string   `db:"suggestions" json:"suggestions"`
	CategoryManuallySet *bool      `db:"category_manually_set" json:"category_manually_set"`
	MerchantManuallySet *bool      `db:"merchant_manually_set" json:"merchant_manually_set"`
	ID                  int64      `db:"id" json:"id"`
	UserID              uuid.UUID  `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) error {
	_, err := q.db.Exec(ctx, updateTransaction,
		arg.EmailID,
		arg.TxDate,
		arg.TxAmountCents,
		arg.TxCurrency,
		arg.TxDirection,
		arg.TxDesc,
		arg.CategoryID,
		arg.Merchant,
		arg.UserNotes,
		arg.ForeignAmountCents,
		arg.ForeignCurrency,
		arg.ExchangeRate,
		arg.Suggestions,
		arg.CategoryManuallySet,
		arg.MerchantManuallySet,
		arg.ID,
		arg.UserID,
	)
	return err
}
