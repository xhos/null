package service

import (
	"context"
	"fmt"

	"null/internal/db/sqlc"
	pb "null/internal/gen/null/v1"

	"github.com/charmbracelet/log"
	"github.com/google/uuid"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// ----- interface --------------------------------------------------------------------------------

type AccountService interface {
	Create(ctx context.Context, req *pb.CreateAccountRequest) (*pb.Account, error)
	Get(ctx context.Context, userID uuid.UUID, accountID int64) (*pb.Account, error)
	Update(ctx context.Context, userID uuid.UUID, req *pb.UpdateAccountRequest) error
	Delete(ctx context.Context, userID uuid.UUID, accountID int64) (int64, error)
	List(ctx context.Context, userID uuid.UUID) ([]*pb.Account, error)
}

type acctSvc struct {
	queries *sqlc.Queries
	log     *log.Logger
}

func newAcctSvc(queries *sqlc.Queries, logger *log.Logger) AccountService {
	return &acctSvc{queries: queries, log: logger}
}

// ----- methods ----------------------------------------------------------------------------------

func (s *acctSvc) Create(ctx context.Context, req *pb.CreateAccountRequest) (*pb.Account, error) {
	userID, err := uuid.Parse(req.GetUserId())
	if err != nil {
		return nil, wrapErr("AccountService.Create", fmt.Errorf("invalid user_id: %w", err))
	}

	anchorBalance := req.GetAnchorBalance()
	anchorCents := moneyToCents(anchorBalance)
	anchorCurrency := anchorBalance.GetCurrencyCode()

	mainCurrency := req.GetMainCurrency()

	// TODO: change default colors
	colors := req.GetColors()
	if len(colors) == 0 {
		colors = []string{"#1f2937", "#3b82f6", "#10b981"}
	} else if len(colors) != 3 {
		return nil, wrapErr(
			"AccountService.Create",
			fmt.Errorf("colors must be exactly 3 hex values, got %d", len(colors)))
	}

	params := sqlc.CreateAccountParams{
		OwnerID:            userID,
		Name:               req.GetName(),
		Bank:               req.GetBank(),
		AccountType:        int16(req.GetType()),
		Alias:              req.Alias,
		AnchorBalanceCents: anchorCents,
		AnchorCurrency:     anchorCurrency,
		MainCurrency:       mainCurrency,
		Colors:             colors,
	}

	created, err := s.queries.CreateAccount(ctx, params)
	if err != nil {
		return nil, wrapErr("AccountService.Create", err)
	}

	return accountRowToPb(created, created.AnchorBalanceCents, created.AnchorCurrency), nil
}

func (s *acctSvc) Get(ctx context.Context, userID uuid.UUID, accountID int64) (*pb.Account, error) {
	row, err := s.queries.GetAccount(ctx, sqlc.GetAccountParams{
		UserID: userID,
		ID:     accountID,
	})
	if err != nil {
		return nil, wrapErr("AccountService.Get", err)
	}

	return accountRowToPb(row.Account, row.BalanceCents, row.BalanceCurrency), nil
}

func (s *acctSvc) Update(ctx context.Context, userID uuid.UUID, req *pb.UpdateAccountRequest) error {
	params := sqlc.UpdateAccountParams{
		ID:     req.GetId(),
		UserID: userID,
	}

	if req.Name != nil {
		params.Name = req.Name
	}
	if req.Bank != nil {
		params.Bank = req.Bank
	}
	if req.AccountType != nil {
		accountType := int16(*req.AccountType)
		params.AccountType = &accountType
	}
	if req.Alias != nil {
		params.Alias = req.Alias
	}
	if req.AnchorDate != nil {
		t := req.AnchorDate.AsTime()
		params.AnchorDate = &t
	}
	if req.AnchorBalance != nil {
		cents := moneyToCents(req.AnchorBalance)
		currency := req.AnchorBalance.CurrencyCode
		params.AnchorBalanceCents = &cents
		params.AnchorCurrency = &currency
	}
	if req.MainCurrency != nil {
		params.MainCurrency = req.MainCurrency
	}
	if len(req.Colors) > 0 {
		params.Colors = req.Colors
	}

	err := s.queries.UpdateAccount(ctx, params)
	if err != nil {
		return wrapErr("AccountService.Update", err)
	}

	anchorFieldsChanged := params.AnchorDate != nil || params.AnchorBalanceCents != nil
	if anchorFieldsChanged {
		if err := s.queries.SyncAccountBalances(ctx, params.ID); err != nil {
			s.log.Warn("failed to sync account balances after updating anchor", "account_id", params.ID, "error", err)
		}
	}

	return nil
}

func (s *acctSvc) Delete(ctx context.Context, userID uuid.UUID, id int64) (int64, error) {
	affected, err := s.queries.DeleteAccount(ctx, sqlc.DeleteAccountParams{
		UserID: userID,
		ID:     id,
	})
	if err != nil {
		return 0, wrapErr("AccountService.Delete", err)
	}
	return affected, nil
}

func (s *acctSvc) List(ctx context.Context, userID uuid.UUID) ([]*pb.Account, error) {
	rows, err := s.queries.ListAccounts(ctx, userID)
	if err != nil {
		return nil, wrapErr("AccountService.List", err)
	}

	accounts := make([]*pb.Account, len(rows))
	for i, row := range rows {
		accounts[i] = accountRowToPb(row.Account, row.BalanceCents, row.BalanceCurrency)
	}

	return accounts, nil
}

// ----- conversion helpers -----------------------------------------------------------------------

func accountRowToPb(a sqlc.Account, balanceCents int64, balanceCurrency string) *pb.Account {
	return &pb.Account{
		Id:            a.ID,
		OwnerId:       a.OwnerID.String(),
		Name:          a.Name,
		Bank:          a.Bank,
		Type:          pb.AccountType(a.AccountType),
		Alias:         a.Alias,
		AnchorDate:    timestamppb.New(a.AnchorDate),
		AnchorBalance: centsToMoney(a.AnchorBalanceCents, a.AnchorCurrency),
		MainCurrency:  a.MainCurrency,
		Colors:        a.Colors,
		CreatedAt:     timestamppb.New(a.CreatedAt),
		UpdatedAt:     timestamppb.New(a.UpdatedAt),
		Balance:       centsToMoney(balanceCents, balanceCurrency),
	}
}
